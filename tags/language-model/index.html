<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: language model - 潘小榭</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="black"><meta name="application-name" content="panxiaoxie"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="black"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="panxiaoxie"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="panxiaoxie"><meta property="og:url" content="https://github.com/PanXiebit"><meta property="og:site_name" content="panxiaoxie"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.qt86.com/cache/1625298592_187938.png"><meta property="article:author" content="panxiaoxie"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://www.qt86.com/cache/1625298592_187938.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.panxiaoxie.cn"},"headline":"潘小榭","image":["http://www.panxiaoxie.cn/img/og_image.png"],"author":{"@type":"Person","name":"Xie Pan"},"publisher":{"@type":"Organization","name":"潘小榭","logo":{"@type":"ImageObject","url":"http://www.panxiaoxie.cn/img/panxiaoxie.png"}},"description":null}</script><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/panxiaoxie.png" alt="潘小榭" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PanXiebit"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">language model</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-29T01:05:10.000Z" title="2021/4/29 上午9:05:10">2021-04-29</time>发表</span><span class="level-item"><time dateTime="2021-07-06T01:42:36.008Z" title="2021/7/6 上午9:42:36">2021-07-06</time>更新</span><span class="level-item">3 分钟读完 (大约471个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/29/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-dynamic-convolution-and-involution/">论文笔记-dynamic convolution and involution</a></h1><div class="content"><p>paper list:   </p>
<ul>
<li>CARAFE: Content-Aware ReAssembly of FEatures  </li>
<li>Involution: Inverting the Inherence of Convolution for Visual Recognition  </li>
<li>Pay less attention with lightweight and dynamic convolutions  </li>
<li>ConvBERT: Improving BERT with Span-based Dynamic Convolution   </li>
<li>Dynamic Region-Aware Convolution  </li>
</ul></div><a class="article-more button is-small is-size-7" href="/2021/04/29/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-dynamic-convolution-and-involution/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-16T07:48:48.000Z" title="2021/4/16 下午3:48:48">2021-04-16</time>发表</span><span class="level-item"><time dateTime="2021-07-06T01:44:52.804Z" title="2021/7/6 上午9:44:52">2021-07-06</time>更新</span><span class="level-item">8 分钟读完 (大约1224个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-unlikelihood-training/">论文笔记-unlikelihood training</a></h1><div class="content"><p>paper list:</p>
<ul>
<li>Neural Text Generation with Unlikelihood Training  </li>
<li>Implicit Unlikelihood Training: Improving Neural Text Generation with Reinforcement Learning</li>
</ul></div><a class="article-more button is-small is-size-7" href="/2021/04/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-unlikelihood-training/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-24T04:11:09.000Z" title="2019/3/24 下午12:11:09">2019-03-24</time>发表</span><span class="level-item"><time dateTime="2021-06-29T07:43:58.440Z" title="2021/6/29 下午3:43:58">2021-06-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/dialogue-system/">dialogue system</a></span><span class="level-item">34 分钟读完 (大约5101个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/">论文笔记-对话系统</a></h1><div class="content"><h2 id="paper"><a href="#paper" class="headerlink" title="paper"></a>paper</h2><p>A Survey on Dialogue Systems: Recent Advances and New Frontiers,  Chen et al. 2018</p>
<h2 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h2><p>这是一篇关于对话系统的综述。</p>
<p>对话系统主要分为两大类：  </p>
<ul>
<li><p>任务导向型（task-oriented) 对话系统</p>
</li>
<li><p>非任务导向型（non-task-oriented）对话系统</p>
<ul>
<li><p>序列到序列模型 sequence-to-sequence models</p>
</li>
<li><p>检索式模型 retrieval-based methods</p>
</li>
</ul>
</li>
</ul>
<h2 id="task-oriented-dialogue-system"><a href="#task-oriented-dialogue-system" class="headerlink" title="task-oriented dialogue system"></a>task-oriented dialogue system</h2><p>面向任务的系统旨在帮助用户完成实际具体的任务，例如帮助用户找寻商品，预订酒店餐厅等。</p>
<p>有两种方式：</p>
<ul>
<li><p>pipeline methods</p>
</li>
<li><p>end-to-end methods</p>
</li>
</ul>
<h3 id="pipeline-methods"><a href="#pipeline-methods" class="headerlink" title="pipeline methods"></a>pipeline methods</h3><p><img src="/2019/03/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/03.png"></p>
<p>其流程是4个步骤：</p>
<ul>
<li><p>language understanding</p>
</li>
<li><p>dialogue state tracking  </p>
</li>
<li><p>policy learning  </p>
</li>
<li><p>natural language generation</p>
</li>
</ul>
<h4 id="language-understanding"><a href="#language-understanding" class="headerlink" title="language understanding"></a>language understanding</h4><p>第一步是 utterance 理解。将给定的 utterance 映射成对应的语义槽 (semantic slots).</p>
<blockquote>
<p>Given an utterance, natural language understanding maps it into semantic slots. The slots are pre-defined according to different scenarios.  </p>
</blockquote>
<blockquote>
<p>slots 都是根据特定的场景定义好的。</p>
</blockquote>
<blockquote>
</blockquote>
<p><img src="/2019/03/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/01.png"></p>
<p>看表格能发现，包含三个任务：  </p>
<ul>
<li><p>intent dection: 这个是 utterance-level classification，也就是一个分类任务  </p>
</li>
<li><p>domain classification: 也是分类任务  </p>
</li>
<li><p>slot filling: 这是 word-level 的任务，可以定义成序列标注问题，输入是一个 utterance，输出是对应每个 word 的 semantic label.</p>
</li>
</ul>
<p>关于 slot filling 的 paper:</p>
<ul>
<li><p>CRF baseline</p>
</li>
<li><p>DBNs:</p>
<ul>
<li><p>Deep belief network based semantic taggers for spoken language understanding</p>
</li>
<li><p>Use of kernel deep convex networks and end-to-end learning for spoken language understanding</p>
</li>
</ul>
</li>
<li><p>RNN:</p>
<ul>
<li><p>Investigation of recurrent-neural-network architectures and learning methods for spoken language understanding, 2013</p>
</li>
<li><p>Deep belief nets for natural language call-routing. 2011</p>
</li>
<li><p>Recurrent neural networks for language understanding, 2013</p>
</li>
<li><p>Spoken language understanding using long short-term memory neural networks. 2014</p>
</li>
</ul>
</li>
</ul>
<h4 id="Dialogue-State-Tracking"><a href="#Dialogue-State-Tracking" class="headerlink" title="Dialogue State Tracking"></a>Dialogue State Tracking</h4><p>对话的状态跟踪，预测每一轮对话 user 的 goal. 对话状态跟踪是确保对话系统健壮性的核心组件。它在对话的每一轮次对用户的目标进行预估，管理每个回合的输入和对话历史，输出当前对话状态。这种典型的状态结构通常称为槽填充或语义框架。</p>
<blockquote>
<p>所以对应的 state 是根据场景预定义好了的嘛？比如 online shopping，对应的 state 可能就有 推荐，比较，下单等等？</p>
</blockquote>
<p>基于传统方法的有很多，基于 deep learning 的有：</p>
<ul>
<li><p>[26] Deep neural network approach for the dialog state tracking challenge. 2013</p>
</li>
<li><p>[58] Multi-domain dialog state tracking using recurrent neural networks. 2015</p>
</li>
<li><p>[59] Neural belief tracker: Data-driven dialogue state tracking, 2017</p>
</li>
</ul>
<h4 id="Policy-learning"><a href="#Policy-learning" class="headerlink" title="Policy learning"></a>Policy learning</h4><p>根据上一步得到的 state，来制定下一步的 action. 很符合强化学习的理念啊，不过需要解决 热启动 (warm-start) 的问题。</p>
<ul>
<li><p>基于规则的监督学习（state 的状态需要规则来定义）:</p>
<ul>
<li>[111] Building task-oriented dialogue systems for online shopping,</li>
</ul>
</li>
<li><p>deep reinforcement learning:</p>
<ul>
<li>[14] Strategic dialogue management via deep reinforcement learning, 2015  </li>
</ul>
</li>
</ul>
<p>基于强化学习的方法已经超过监督学习了。</p>
<h4 id="natural-language-generation"><a href="#natural-language-generation" class="headerlink" title="natural language generation"></a>natural language generation</h4><p>一个好的生成器通常依赖于几个因素:适当性、流畅性、可读性和变化性。传统的NLG方法通常是执行句子计划。它将输入语义符号映射到代表话语的中介形式，如树状或模板结构，然后通过表面实现将中间结构转换为最终响应。深度学习比较成熟的方法是基于LSTM的encoder-decoder形式，将问题信息、语义槽值和对话行为类型结合起来生成正确的答案。同时利用了注意力机制来处理对解码器当前解码状态的关键信息，根据不同的行为类型生成不同的回复。</p>
<ul>
<li>[123] Context-aware nat- ural language generation for spoken dialogue systems. Zhou et al, 2016 COLING  </li>
</ul>
<blockquote>
<p>adopted an encoder-decoder LSTM-based structure to incorporate the question information, semantic slot values, and dialogue act type to generate correct answers. It used the attention mechanism to attend to the key information conditioned on the current decoding state of the decoder. Encoding the di- alogue act type embedding, the neural network-based model is able to generate variant answers in response to different act types.</p>
</blockquote>
<h3 id="end-to-end-model"><a href="#end-to-end-model" class="headerlink" title="end-to-end model"></a>end-to-end model</h3><p>传统的 pipeline 的方法的缺点：</p>
<ul>
<li><p>user 的反馈很难传递到每一个 module</p>
</li>
<li><p>每一个 module 都是相互依赖的  (process interde- pendence)</p>
</li>
</ul>
<p>也就是在不同的 domain 或者 scenarios 时，pipeline 设计的对话系统可能就不使用的，因为 slots 和 features 都是 task-specificed，都会相应的改变。而这些过程都需要大量的人工工程。</p>
<p>因此我们需要 end-to-end model。与传统的 pipeline 模型不同，端到端模型使用一个模块，并与结构化的外部数据库交互。</p>
<ul>
<li><p>network-based end-to-end 模型需要大量的标注数据</p>
<ul>
<li><p>Learning end-to-end goal-oriented dialog, Bordes et al, 2017 ICLR</p>
</li>
<li><p>A network-based end-to-end trainable task-oriented di- alogue system, 2017 ACL</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>end-to-end reinforcement learning 在对话管理中，联合训练 state tracking 和 policy learning， 从而使得模型鲁棒性更强。</p>
<ul>
<li>Towards end-to-end learn- ing for dialog state tracking and management us- ing deep reinforcement learning，2016 ACL</li>
</ul>
</li>
<li><p>task-completion neural dialogue system, 其目标就是完成一个任务。</p>
<ul>
<li>End-to-end task- completion neural dialogue systems，2017</li>
</ul>
</li>
</ul>
<p>以任务为导向的对话系统通常还需要查询外部知识库。传统的采用的方法就是通过 semantic parsing 形成一个 query，然后去匹配外部知识库，通过检索得到想要的 entries. 其缺点是：</p>
<ul>
<li><p>检索的结果不包含有关语义分析中的不确定性信息</p>
</li>
<li><p>检索的过程是不可微的 (non-differentiabl), 因此 semantic parsing 和 dialogue policy 只能分别训练，导致 online end-to-end 的模型很难部署。</p>
</li>
</ul>
<p>解决这个问题的 paper:  </p>
<ul>
<li><a href>Key-value retrieval networks for task-oriented dialogue, 2017</a> augmented existing recurrent network architectures with a differentiable attention-based key-value retrieval mechanism over the entries of a knowledge base, which is inspired by key-value memory networks.  </li>
</ul>
<ul>
<li><a href>Towards end-to-end reinforcement learning of dialogue agents for information ac- cess, 2017 ACL</a> replaced symbolic queries with an induced “soft” posterior distribution over the knowledge base that indicates which entities the user is interested in. Integrating the soft retrieval process with a reinforcement learner  </li>
</ul>
<ul>
<li><a href>Hybrid code networks: practical and efficient end-to-end dialog control with supervised and reinforcement learning. 2017 ACL</a> combined an RNNwith domain-specific knowledge encoded as software and system action templates.  </li>
</ul>
<h2 id="Non-task-oriented-dialogue-system"><a href="#Non-task-oriented-dialogue-system" class="headerlink" title="Non-task-oriented dialogue system"></a>Non-task-oriented dialogue system</h2><p>非任务导向型对话系统也就是聊天机器人， 是通过生成模型或基于检索的方法实现的。 生成模型能够生成更合适的回复（也就是跟上下文语义更接近），而这些回复可能从来没有出现在语料库中，而基于检索的模型则能得到具有信息充裕 (informative) 和 fluent 的回复。</p>
<h3 id="Neural-Generative-models"><a href="#Neural-Generative-models" class="headerlink" title="Neural Generative models"></a>Neural Generative models</h3><p>深度学习在机器翻译中的成功应用，即神经机器翻译，激发了人们对神经生成对话研究的热情。</p>
<p>最开始也有一篇 paper，将对话当最机器翻译来做的 paper. 把对话看作是将 post 翻译成 response。但是区别在于 response 的范围很广，而且 post 和 response 并不像翻译的两个句子之间存在对齐关系。</p>
<p>目前神经生成模型的热门研究课题，主要是讨论：</p>
<ul>
<li><p>response diversity</p>
</li>
<li><p>modeling topics and personalities</p>
</li>
<li><p>leveraging outside knowledge base</p>
</li>
<li><p>the interactive learning</p>
</li>
<li><p>evaluation</p>
</li>
</ul>
<h4 id="Sequence-to-Sequence-Models"><a href="#Sequence-to-Sequence-Models" class="headerlink" title="Sequence-to-Sequence Models"></a>Sequence-to-Sequence Models</h4><p><img src="/2019/03/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/02.png"></p>
<p>这个就是基本的 seq2seq 模型。好奇的是，如何解决多轮对话，如何结合 history 信息，如何控制对话的状态，这些都需要深入看 paper 吧。</p>
<h4 id="Dialogue-Context"><a href="#Dialogue-Context" class="headerlink" title="Dialogue Context"></a>Dialogue Context</h4><p>考虑历史对话的历史信息的能力是建立可保持对话活跃的对话系统的关键。</p>
<ul>
<li><p>基于 RNN language model 的形式：  </p>
<ul>
<li><a href>A neural network approach to context-sensitive generation of conversational responses, ACL 2015</a> 通过连续的表示或单词和短语的嵌入来表示整个对话历史（包括当前消息），类似于 RNN language model 的 decoder 过程，这样就能保证前后生成的 response 是有关系的，后者是依赖于前者。[12] 也是这么干的。</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用 hierarchical model:</p>
<ul>
<li>[68] 先分别对 individual utterance 进行建模，然后将他们整合在一起。<a href>Hierarchical recurrent attention network for response generation, 2017</a> 引入了 attention mechanism, 从而 focus 最相关或者是最重要的部分 word-level or utterance-level. <a href>How to make context more useful? an empirical study on context-aware neural conversational models., ACL 2017</a> 对有无层次结构的模型进行了对比，证明有层次结构的模型效果更好。</li>
</ul>
</li>
</ul>
<h4 id="Response-Diversity"><a href="#Response-Diversity" class="headerlink" title="Response Diversity"></a>Response Diversity</h4><blockquote>
<p>A challenging problem in current sequence-to-sequence dialogue systems is that they tend to generate trivial or non-committal, universally relevant responses with little meaning, which are often involving high frequency phrases along the lines of I dont know or Im OK.  </p>
</blockquote>
<p>在当前的序列对话系统中，一个具有挑战性的问题是，它们倾向于产生意义不大的普通或不重要的、普适的回答，而这些回答往往涉及到“我不知道”或者“我很好”这样的高频率短语。</p>
<ol>
<li>MMI and IDF  </li>
</ol>
<p>模型的这种行为可以归咎于模型赋予了 “safe” response 更高的概率。<a href>A diversity-promoting objective function for neural con- versation models. ACL 2016</a> 使用了 Maximum Mutual Information 作为优化目标,这是最初在语音识别领域引入的。 它测量了输入和输出之间的相互依赖关系，并考虑了消息回复的逆向依赖性。 <a href>An attentional neural conversation model with improved speci- ficit, 2016</a> 结合逆文档频率（IDF）到训练过程来评价回复的多样性。（在不同的 document 中出现的回复次数越多，其相应的权重越低）。</p>
<ol start="2">
<li>beam-search</li>
</ol>
<p>一些研究表明，解码的过程也是回复冗余的另一个缘由。[86][72][42] 发现 beam-search 在生成候选答案时中缺乏多样性。[86] 提出了一种衡量不同回复之间的相似度的方法，类似于正则惩罚项吧，来增强 beam-search 的目标函数。[72] 提出了一种随机 beam-search 的方法，[42] 则使用了一个惩罚项来惩罚来自同一父节点中的子节点的展开。</p>
<ol start="3">
<li>re-ranking</li>
</ol>
<p>[38][77][72] 结合全局特征，重新执行 re-ranking 的步骤，从而避免生成 dull or generic 的回复。</p>
<ol start="4">
<li>PMI  </li>
</ol>
<p>[57] 猜测问题不仅仅在于解码和 respones 的频率，而且消息本身也缺乏足够的信息。 它提出使用逐点互信息（PMI）来预测名词作为关键词，反映答复的主要依据，然后生成一个包含给定关键字的答复.</p>
<ol start="5">
<li>latent variable   </li>
</ol>
<p>另一系列工作着重于通过引入随机隐变量来产生更多不同的输出。 他们表明，自然对话不是确定性的 —— 对同一信息的答复可能会因人而异。 但是，当前回复是从确定性 encoder-decoder 模型中采样的。 通过整合隐变量，这些模型的优点是，在生成时，他们可以通过首先对隐变量的分配进行采样，然后确定性地进行解码，从分布中采样回复。</p>
<ul>
<li><p><a href>A hierarchical latent vari- able encoder-decoder model for generating dialogues, AAAI 2019</a> 将因变量引入到 hierachical dialogue model framework，The latent variable is designed to make high-level decisions like topic or sentiment.      </p>
</li>
<li><p><a href>A conditional variational framework for dialog generation. ACL 2017</a>  conditioned the latent variable on explicit attributes to make the latent variable more interpretable. These attributes can be either manually assigned or automatically detected such topics, and personality.</p>
</li>
</ul>
<h4 id="Topic-and-Personality"><a href="#Topic-and-Personality" class="headerlink" title="Topic and Personality"></a>Topic and Personality</h4><p>明确对话的内在属性是提高对话多样性和保证一致性的另一种方法。在不同的属性中，主题和个性被广泛地进行研究探讨。</p>
<ol>
<li><a href>Topic aware neural response generation, AAAI 2017</a> 注意到人们经常把他们的对话与主题相关的概念联系起来，并根据这些概念做出他们的回复。他们使用Twitter LDA模型来获取输入的主题，将主题信息和输入表示输入到一个联合注意模块中，并生成与主题相关的响应。</li>
</ol>
<ol start="2">
<li><a href>Multiresolution recurrent neural networks: An application to dialogue response generation. AAAI 2017</a> 对粗粒度的 tokens sequence 和 dialogue generation 进行联合建模，粗粒度的 tokens 主要是用来探索 high-level 的语义信息，通常是 name entity 或 nouns.</li>
</ol>
<ol start="3">
<li><a href>Emotional chatting machine: Emotional conversation generation with internal and external memory</a> 将情感 embedding 融入到了对话生成中。<a href>Affective neural response generation, 2017</a> 通过三种方式增强回复的情感：  </li>
</ol>
<ul>
<li><p>incorporating cognitive engineered affective word embeddings  </p>
</li>
<li><p>augmenting the loss objective with an affect-constrained objective function  </p>
</li>
<li><p>injecting affective dissimilarity in diverse beam-search inference procedure  </p>
</li>
</ul>
<ol start="6">
<li><a href>Assigning personality/identity to a chatting machine for coherent conversation generation</a> 让对话个性化，并且保持一致性。<a href>Neural per- sonalized response generation as domain adaptation</a> 提出了一种两阶段的训练方法，使用大规模数据对模型进行初始化，然后对模型进行微调，生成个性化响应。</li>
</ol>
<ol start="7">
<li><a href>Personalizing a dialogue system with transfer reinforcement learning</a> 使用强化学习来消除对话的前后不一致性。</li>
</ol>
<h4 id="Outside-Knowledge-Base"><a href="#Outside-Knowledge-Base" class="headerlink" title="Outside Knowledge Base"></a>Outside Knowledge Base</h4><p>人类对话与对话系统之间的一个重要区别是它是否与现实相结合。结合外部知识库(KB)是一种很有前途的方法，可以弥补背景知识之间的差距，即对话系统和人之间的差距。记忆网络（Memory Network）是一种以知识库处理问题的经典方法。因此，它非常直接的别用于在对话生成中。实际研究表明，所提出的模型能够通过参考知识库中的事实来生成对问题的自然和正确答案。</p>
<ul>
<li><p><a href>A knowledge-grounded neural conversation model, 2017</a>  </p>
</li>
<li><p><a href>A neural network approach for knowledge-driven response generation. COLING 2016</a>  </p>
</li>
<li><p><a href>Neural generative question answering,IJCAI 2016</a>  </p>
</li>
</ul>
<h4 id="Interactive-Dialogue-learning"><a href="#Interactive-Dialogue-learning" class="headerlink" title="Interactive Dialogue learning"></a>Interactive Dialogue learning</h4><p>通过交互来学习是对话系统的最终目标之一。<a href>Deep reinforcement learning for dialogue generation, ACL 2016</a> 利用两个虚拟智能体模拟对话。它们定义了对描述一个较好的对话的汇报的一个简单的启发式的估计：好的对话是有前瞻性[1]或者交互式的（当前轮为下一轮对话铺垫），是信息丰富的和连贯的。一个RNN的编码器-解码器所有参数定义了一个在无穷大的动作空间上从所有可能的话语中进行选择的策略。智能体是通过策略梯度方法 <a href>Simple statistical gradient-following al- gorithms for connectionist reinforcement learning, 1992</a> 来优化由开发者定义的长期奖励，而不是通过标准seq2seq的MLE目标函数来学习策略。[32]进一步试图提高机器人从交互中学习的能力。通过对文本和数字反馈使用策略学习和前向预测，该模型可以通过（半）在线方式与人进行交互来提高自身性能。</p>
<p>由于大多数人类在对答案并不自信时通常会要求提供一些澄清或者提示，所有机器人拥有这种能力也是相当自然的。<a href>Learning through dialogue interactions by asking questions. 2017</a> 定义了机器人在回答问题时遇到困难时的三种情况。与不采用提问的实验结果相比，这种方法在一些情况下有了很大的改进。<a href>Deal or no deal? end-to-end learning of negotiation dialogues, ACL 2017</a> 在谈判任务中进行了探索。由于传统的序列到序列模型模拟人类的对话没有优化具体的目标，这项工作采取了面向目标的训练和解码方法，并展示了一个有价值的视角。</p>
<h4 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h4><p>评价生成回复的质量是对话系统的一个重要方面。任务导向型的对话系统可以基于人工生成的监督信号进行评估，例如任务完成测试或用户满意度评分等，然而，由于高回复的多样性，自动评估非任务导向的对话系统所产生的响应的质量仍然是一个悬而未决的问题。目前的方法有以下几种：  </p>
<ul>
<li><p>BLEU, METEOR, and ROUGE 值，也就是直接计算 word overlap、ground truth和你生成的回复。由于一句话可能存在多种回复，因此从某些方面来看，BLEU 可能不太适用于对话评测。   </p>
</li>
<li><p>计算 embedding的距离，这类方法分三种情况：直接相加求平均、先取绝对值再求平均和贪婪匹配。</p>
</li>
<li><p>进行图灵测试，用 retrieval 的 discriminator 来评价回复生成。</p>
</li>
</ul>
<h3 id="Retrieval-based-Methods"><a href="#Retrieval-based-Methods" class="headerlink" title="Retrieval-based Methods"></a>Retrieval-based Methods</h3><p>基于检索的方法从候选回复中选择回复。检索方法的关键是消息-回复匹配，匹配算法必须克服消息和回复之间的语义鸿沟。</p>
<h4 id="single-turn-response-match"><a href="#single-turn-response-match" class="headerlink" title="single-turn response match"></a>single-turn response match</h4><p>$$match(x,y)=x^TAy$$</p>
<p><a href>Convolutional neu- ral network architectures for matching natural lan- guage sentences, 2014</a> 利用深度卷积神经网络体系结构改进模型，学习消息和响应的表示，或直接学习两个句子的相互作用表示，然后用多层感知器来计算匹配的分数。</p>
<h4 id="multi-turn-response"><a href="#multi-turn-response" class="headerlink" title="multi-turn response"></a>multi-turn response</h4><ul>
<li><a href>The ubuntu dialogue corpus: A large dataset for research in unstructured multi-turn dialogue systems, ACL 2015</a> encoded the context (a concatenation of all previous utterances and current message) and candidate response into a context vector and a response vector through a RNN/LSTM based structure, respectively, and then computed the matching degree score based on those two vectors.</li>
</ul>
<ul>
<li><a href>Learning to respond with deep neural networks for retrieval-based human- computer conversation system, ACM 2016</a> selected the previous utterances in different strategies and combined them with current messages to form a reformulated context.</li>
</ul>
<ul>
<li><a href>Multi-view response selection for human-computer conversation. ACL 2016</a> performed context-response matching on not only the general word level context vector but also the utterance level context vector.</li>
</ul>
<ul>
<li><a href>Sequential matching network: A new architecture for multi-turn response selection in retrieval-based chatbots. ACL 2017</a> further improved the leveraging of ut- terances relationship and contextual information by match- ing a response with each utterance in the context on multi- ple levels of granularity with a convolutional neural network, and then accumulated the vectors in a chronological order through a recurrent neural network to model relationships among utterances</li>
</ul>
<h3 id="Hybrid-Methods"><a href="#Hybrid-Methods" class="headerlink" title="Hybrid Methods"></a>Hybrid Methods</h3><p>将生成和检索方法结合起来能对系统性能起到显著的提升作用。基于检索的系统通常给出精确但是较为生硬的答案，而基于生成的系统则倾向于给出流畅但却是毫无意义的回答。在集成模型中，被抽取的候选对象和原始消息一起被输入到基于RNN的回复生成器中。这种方法结合了检索和生成模型的优点，这在性能上具备很大的优势。</p>
<ul>
<li><p><a href>Two are better than one: An ensemble of retrieval- and generation-based dialog systems, 2016</a>  </p>
</li>
<li><p><a href>Alime chat: A sequence to sequence and rerank based chatbot engine. ACL 2017</a></p>
</li>
<li><p><a href>A deep reinforcement learning chatbot, 2017</a></p>
</li>
</ul>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>端到端的框架不仅在非面向任务的聊天对话系统中流行，而且在面向任务的对话系统中逐步流行起来。深度学习能够利用大量的数据，从而模糊了任务导向型对话系统和非任务导向型对话系统之间的界限。值得注意的是，目前的端到端模型仍然远非完美。尽管取得了上述成就，但这些问题仍然具有挑战性。接下来，我们将讨论一些可能的研究方向。</p>
<ul>
<li>Swift Warm-Up，在一些新的领域，特定领域对话数据的收集和对话系统的构建是比较困难的。未来的趋势是对话模型有能力从与人的交互中主动去学习。  </li>
</ul>
<ul>
<li>Deep Understanding. 深度理解。现阶段基于神经网络的对话系统极大地依赖于大量标注好的数据，结构化的知识库以及对话语料数据。在某种意义上产生的回复仍然缺乏多样性，有时并没有太多的意义，因此对话系统必须能够更加有效地深度理解语言和真实世界。  </li>
</ul>
<ul>
<li>Privacy Protection. 目前广泛应用的对话系统服务于越来越多的人。很有必要注意到的事实是我们使用的是同一个对话助手。通过互动、理解和推理的学习能力，对话助手可以无意中隐蔽地存储一些较为敏感的信息。因此，在构建更好的对话机制时，保护用户的隐私是非常重要的。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-01-15T01:02:14.000Z" title="2019/1/15 上午9:02:14">2019-01-15</time>发表</span><span class="level-item"><time dateTime="2021-06-29T08:12:09.159Z" title="2021/6/29 下午4:12:09">2021-06-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/language-model/">language model</a></span><span class="level-item">8 分钟读完 (大约1217个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/">论文笔记-预训练语言模型2-ULMFiT</a></h1><div class="content"><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="对比之前的几种模型"><a href="#对比之前的几种模型" class="headerlink" title="对比之前的几种模型"></a>对比之前的几种模型</h3><h4 id="concatenate-embeddings-ELMo"><a href="#concatenate-embeddings-ELMo" class="headerlink" title="concatenate embeddings: ELMo"></a><strong>concatenate embeddings</strong>: ELMo</h4><blockquote>
<p>Recent approaches that concatenate embeddings derived from other tasks with the input at different layers (Peters et al., 2017; McCann et al., 2017; Peters et al., 2018) still train the main task model from scratch and treat pretrained embeddings as fixed parameters, limiting their usefulness.  </p>
</blockquote>
<p>这篇 paper 是在 elmo 之后，而 elmo 虽然相对出名，影响力更大，但是 elmo 仍旧只是一种 word embedding 的预训练，在下游任务中还是需要从头训练模型。</p>
<p>ELMo有以下几个步骤：  </p>
<ul>
<li><p>利用LM任务进行预训练  </p>
</li>
<li><p>再利用目标领域的语料对LM模型做微调  </p>
</li>
<li><p>最后针对目标任务进行 concatenate embedding，然后训练模型</p>
</li>
</ul>
<h4 id="pretraining-LM"><a href="#pretraining-LM" class="headerlink" title="pretraining LM:"></a><strong>pretraining LM:</strong></h4><blockquote>
<p>In light of the benefits of pretraining (Erhan et al., 2010), we should be able to do better than randomly initializing the remaining parameters of our models. However, inductive transfer via finetuning has been unsuccessful for NLP (Mou et al., 2016). Dai and Le (2015) first proposed finetuning a language model (LM) but require millions of in-domain documents to achieve good performance, which severely limits its applicability.  </p>
</blockquote>
<p>直接使用在 general-domain 上预训练好的语言模型，然后通过 fine-tune 进行迁移学习， 仍旧需要大量的 in-domain 的文档才能获得比较好的 performance.</p>
<h4 id="ULMFiT"><a href="#ULMFiT" class="headerlink" title="ULMFiT"></a>ULMFiT</h4><blockquote>
<p>We show that not the idea of LM fine-tuning but our lack of knowledge of how to train them effectively has been hindering wider adoption. LMs overfit to small datasets and suffered catastrophic forgetting when fine-tuned with a classifier. Compared to CV, NLP models are typically more shallow and thus require different fine-tuning methods.  </p>
</blockquote>
<p>作者认为，预训练语言模型的方式并不是不好，只是训练方法的问题导致了他们表现局限性。想对于 CV， NLP 中的很多任务所需要的语义更浅层。而将 LMs 在小数据集上 fine-tune 时会导致严重的遗忘。</p>
<p>于是，作者提出了 Universal Language Model Fine-tuning(ULMFiT)  </p>
<ul>
<li><p>通用的语言模型微调  </p>
</li>
<li><p>discriminative fine-tuning, slanted triangular learning rates  </p>
</li>
<li><p>gradual unfreezing  </p>
</li>
</ul>
<h2 id="Universal-Language-Model-Fine-tuning"><a href="#Universal-Language-Model-Fine-tuning" class="headerlink" title="Universal Language Model Fine-tuning"></a>Universal Language Model Fine-tuning</h2><p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/01.png"></p>
<p>主要分为 3 部分：  </p>
<ul>
<li><p>General-domain LM pretraining  </p>
</li>
<li><p>Target task LM fine-tuning  </p>
</li>
<li><p>Target task classifier fine-tuning  </p>
</li>
</ul>
<h3 id="General-domain-LM-pretraining"><a href="#General-domain-LM-pretraining" class="headerlink" title="General-domain LM pretraining"></a>General-domain LM pretraining</h3><p>Wikitext-103 (Merity et al., 2017b) consisting of 28,595 preprocessed Wikipedia articles and 103 million words.  </p>
<p>在足够大的 general-domain 语料库上进行预训练。</p>
<h3 id="Target-task-LM-fine-tuning"><a href="#Target-task-LM-fine-tuning" class="headerlink" title="Target task LM fine-tuning"></a>Target task LM fine-tuning</h3><h4 id="discriminative-fine-tunin"><a href="#discriminative-fine-tunin" class="headerlink" title="discriminative fine-tunin"></a>discriminative fine-tunin</h4><p>在目标语料库 in-domain 上进行 fine-tune. 这部分会收敛的很快，并且在小数据集上依旧会有很好的泛化性。  </p>
<blockquote>
<p>As different layers capture different types of information (Yosinski et al., 2014), they should be fine-tuned to different extents.  </p>
</blockquote>
<p>不同的 layer 能捕捉不同程度的信息，于是，作者提出了 discriminative fine-tuning. 不同的 layer 具有不同的 learning rate. L 表示总的 layer 数目。</p>
<p>$${\theta^1,\theta^2, …, \theta^L}$$</p>
<p>$${\eta^1,\eta^2, …, \eta^L}$$</p>
<blockquote>
<p>Instead of using the same learning rate for all layers of the model, discriminative fine-tuning allows us to tune each layer with different learning rates.</p>
</blockquote>
<p>原本的 SGD 是这样的：</p>
<p>$$\theta_t = \theta_{t-1}-\eta\cdot\nabla_{\theta}J(\theta)$$</p>
<p>改进之后：</p>
<p>$$\theta_t^l = \theta_{t-1}^l-\eta^l\cdot\nabla_{\theta^l}J(\theta)$$</p>
<p>作者通过经验发现：先选择最后一层的学习率 $\eta^L$，然后计算每一层的学习率 $\eta^{l-1}=\eta^l/2.6$</p>
<h4 id="Slanted-triangular-learning-rates"><a href="#Slanted-triangular-learning-rates" class="headerlink" title="Slanted triangular learning rates"></a>Slanted triangular learning rates</h4><p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/02.png"></p>
<ul>
<li><p>T 是迭代次数，这里实际上是 $epochs \times \text{number of per epoch}$  </p>
</li>
<li><p>cut_frac 是增加学习率的迭代步数比例  </p>
</li>
<li><p>cut 是学习率增加和减少的临界迭代步数  </p>
</li>
<li><p>p 是一个分段函数，分别递增和递减  </p>
</li>
<li><p>ratio 表示学习率最小时，与最大学习率的比例。比如 t=0时，p=0, 那么 $\eta_0=\dfrac{\eta_{max}}{ratio}$  </p>
</li>
</ul>
<p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/3.png"></p>
<p>作者通过实验发现，cut_frac=0.1, ratio=32, $\eta_max=0.01$</p>
<h3 id="Target-task-classifier-fine-tuning"><a href="#Target-task-classifier-fine-tuning" class="headerlink" title="Target task classifier fine-tuning"></a>Target task classifier fine-tuning</h3><p>针对分类任务，加上 two additional linear blocks.</p>
<h4 id="concat-pooling"><a href="#concat-pooling" class="headerlink" title="concat pooling"></a>concat pooling</h4><p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/04.png"></p>
<h4 id="gradul-unfreezing"><a href="#gradul-unfreezing" class="headerlink" title="gradul unfreezing"></a>gradul unfreezing</h4><p>逐渐 unfreeze layers:  </p>
<blockquote>
<p>We first unfreeze the last layer and fine-tune all unfrozen layers for one epoch. We then unfreeze the next lower frozen layer and repeat, until we finetune all layers until convergence at the last iteration.</p>
</blockquote>
<h4 id="BPTT-for-Text-Classification"><a href="#BPTT-for-Text-Classification" class="headerlink" title="BPTT for Text Classification"></a>BPTT for Text Classification</h4><p>backpropagation through time(BPTT)</p>
<blockquote>
<p>We divide the document into fixed length batches of size b. At the beginning of each batch, the model is initialized with the final state of the previous batch; we keep track of the hidden states for mean and max-pooling; gradients are back-propagated to the batches whose hidden states contributed to the final prediction. In practice, we use variable length backpropagation sequences (Merity et al., 2017a).  </p>
</blockquote>
<p>什么意思？并不是一个 batch 更新一次梯度，而是累加一定的 batch 之后在更新梯度？  </p>
<p>能增加泛化性？</p>
<h4 id="Bidirectional-language-model"><a href="#Bidirectional-language-model" class="headerlink" title="Bidirectional language model"></a>Bidirectional language model</h4><p>独立的对 forward-LM, backward-LM 进行 fine-tune, 然后平均。</p>
<h2 id="experiment"><a href="#experiment" class="headerlink" title="experiment"></a>experiment</h2><h3 id="与其他模型对比"><a href="#与其他模型对比" class="headerlink" title="与其他模型对比"></a>与其他模型对比</h3><p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/05.png"></p>
<h3 id="ablations"><a href="#ablations" class="headerlink" title="ablations"></a>ablations</h3><p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/06.png"></p>
<p>“from scratch”: 没有 fine-tune  </p>
<p>“supervised”: 表示仅仅在 label examples 进行 fine-tune  </p>
<p>“semi-supervised”: 表示在 unable examples 上也进行了 fine-tune</p>
<h3 id="对-tricks-进行分析"><a href="#对-tricks-进行分析" class="headerlink" title="对 tricks 进行分析"></a>对 tricks 进行分析</h3><p><img src="/2019/01/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B2-ULMFiT/07.png"></p>
<p>“full” :fine-tuning the full model  </p>
<p>“discr”: discriminative fine-tuning  </p>
<p>“stlr”: slanted triangular learning rates</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-12-17T06:50:31.000Z" title="2018/12/17 下午2:50:31">2018-12-17</time>发表</span><span class="level-item"><time dateTime="2021-06-29T08:12:09.158Z" title="2021/6/29 下午4:12:09">2021-06-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/language-model/">language model</a></span><span class="level-item">21 分钟读完 (大约3119个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/">论文笔记-BERT</a></h1><div class="content"><h2 id="BERT-Bidirectional-Encoder-Representations-from-Transformers"><a href="#BERT-Bidirectional-Encoder-Representations-from-Transformers" class="headerlink" title="BERT(Bidirectional Encoder Representations from Transformers.)"></a>BERT(Bidirectional Encoder Representations from Transformers.)</h2><p>对于 BERT 重点在于理解 Bidirectional 和 masked language model.</p>
<h3 id="Why-Bidirectional"><a href="#Why-Bidirectional" class="headerlink" title="Why Bidirectional?"></a>Why Bidirectional?</h3><p>对于预训练的表示，单向语言模型因为无法融合下文的信息，其能力是非常有限的，尤其是对类似于 SQuAD 这样需要结合上下文信息的任务。</p>
<p>对比 OpenAI GPT 和 BERT. 为什么 OpenAI GPT 不能采用双向 self-attention 呢？</p>
<p>传统的语言模型的定义，计算句子的概率：</p>
<p>$$P(S)=p(w_1,w_2, …, w_n)=p(w1)p(w_2|w_1)…p(w_n|w_1…w_{n-1})=\prod_{i=1}^m p(w_i|w_1…w_{i-1})$$</p>
<p>前向 RNN 语言模型：</p>
<p>$$P(S)=\prod_{i=1}^m p(w_i|w_1…w_{i-1})$$</p>
<p>也就是当前词的概率只依赖前面出现词的概率。</p>
<p>后向 RNN 语言模型  </p>
<p>$$P(S)=\prod_{i=1}^m p(w_i|w_{i+1}…w_{m})$$</p>
<p>也就是当前词的概率只依赖后面出现的词的概率。</p>
<p>ELMo 就是这样的双向语言模型(BiLM)</p>
<p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/02.jpg"></p>
<p>但是 RNN 相比 self-attention 对上下文信息 (contextual information)的利用相对有限，而且 ELMo 只能是一层双向，并不能使用多层。其原因和 GPT 无法使用 双向 编码的原因一样。</p>
<p>对于 GPT 如果它使用双向，那么模型就能准确的学到到句子中的下一个词是什么，并能 100% 的预测出下一个词。比如 “I love to work on NLP.” 在预测 love 的下一个词时，模型能看到 to，所以能很快的通过迭代学习到 “to” 100% 就是 love 的下一个词。所以，这导致模型并不能学到想要的东西（句法、语义信息）。</p>
<p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/03.png"> <img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/04.png"></p>
<p>那么 BERT 是怎么处理双向这个问题的呢？ 它改变了训练语言模型的任务形式。提出了两种方式 “masked language model” and “next sentence generation”. 再介绍这两种训练方式之前，先说明下输入形式。</p>
<h3 id="Input-representation"><a href="#Input-representation" class="headerlink" title="Input representation"></a>Input representation</h3><p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/05.png"></p>
<ul>
<li><p>position embedding: 跟 Transformer 类似    </p>
</li>
<li><p>sentence embedding, 同一个句子的词的表示一样，都是 $E_A$ 或 $E_B$. 用来表示不同的句子具有不同的含义  </p>
</li>
<li><p>对于 [Question, Answer] 这样的 sentence-pairs 的任务，在句子末尾加上 [SEP].  </p>
</li>
<li><p>对于文本分类这样的 single-sentence 的任务，只需要加上 [CLS], 并且 sentence embedding 只有 $E_A$.</p>
</li>
</ul>
<h3 id="masked-language-model"><a href="#masked-language-model" class="headerlink" title="masked language model"></a>masked language model</h3><p>何为 “masked LM”? idea 来源于 closed tasked. 原本的语言模型是预测所有语料中的下一个词，而 MLM 是在所有的 tokens 中随机选取 15% 的进行 mask，然后只需要预测被 mask 的词。这样以来，就能训练双向语言模型了。</p>
<p>但是存在一个问题，这样 pre-training 训练出来的语言模型并不能拿去做 fine-tune. 原因是在 fine-token 中从来没有见过 &lt;MASK&gt; 这个词。作者采用这样的策略：  </p>
<p>具体的操作，以 “My dog is hairy” 为例，mask “hairy” 这个词：</p>
<ul>
<li><p>“My dog is &lt;MASK&gt;“. 80% 被 <MASK> 代替  </MASK></p>
</li>
<li><p>“My dog is apple”.  10% 被一个随机的 token 代替  </p>
</li>
<li><p>“My dog is hairy”.  10% 保持原来的样子  </p>
</li>
</ul>
<h4 id="为什么不用-lt-MASK-gt-代替所有的-token？"><a href="#为什么不用-lt-MASK-gt-代替所有的-token？" class="headerlink" title="为什么不用 &lt;MASK&gt; 代替所有的 token？"></a>为什么不用 &lt;MASK&gt; 代替所有的 token？</h4><blockquote>
<p>If the model had been trained on only predicting ‘&lt;MASK&gt;’ tokens and then never saw this token during fine-tuning, it would have thought that there was no need to predict anything and this would have hampered performance. Furthermore, the model would have only learned a contextual representation of the ‘&lt;MASK&gt;’ token and this would have made it learn slowly (since only 15% of the input tokens are masked). By sometimes asking it to predict a word in a position that did not have a ‘&lt;MASK&gt;’ token, the model needed to learn a contextual representation of all the words in the input sentence, just in case it was asked to predict them afterwards.  </p>
</blockquote>
<p>如果模型在预训练的时候仅仅只预测 &lt;MASK&gt;, 然后在 fine-tune 的时候从未见过 &lt;MASK&gt; 这个词，那么模型就不需要预测任何词，在 fine-tune 时会影响性能。  </p>
<p>更严重的是，如果仅仅预测 &lt;MASK&gt;, 那么模型只需要学习 &lt;MASK&gt; 的上下文表示，这会导致它学习的很慢。  </p>
<p>如果让模型在某个位置去预测一个不是 &lt;MASK&gt; 的词，那么模型就需要学习所有 tokens 的上下文表示，因为万一需要预测这个词呢。</p>
<h4 id="只需要-random-tokens-足够吗？为什么还需要-10-的完整的-sentence"><a href="#只需要-random-tokens-足够吗？为什么还需要-10-的完整的-sentence" class="headerlink" title="只需要 random tokens 足够吗？为什么还需要 10% 的完整的 sentence?"></a>只需要 random tokens 足够吗？为什么还需要 10% 的完整的 sentence?</h4><blockquote>
<p>Well, ideally we want the model’s representation of the masked token to be better than random. By sometimes keeping the sentence intact (while still asking the model to predict the chosen token) the authors biased the model to learn a meaningful representation of the masked tokens.  </p>
</blockquote>
<p>使得模型具有偏置，更倾向于获得有意义的 masked token.</p>
<p>在知乎上问了这个问题，大佬的回复跟这篇 blog 有点差异，但实际上意思是一样的：  </p>
<p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/11.png"></p>
<p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/10.png"></p>
<p>总结下：  </p>
<p>为什么不能完全只有 &lt;MASK&gt; ?  如果只有 &lt;MASK&gt;, 那么这个预训练模型是有偏置的，也就是学到一种方式，用上下文去预测一个词。这导致在 fine-tune 时，会丢一部分信息，也就是知乎大佬第一部分所说的。</p>
<p>所以加上 random 和 ture token 是让模型知道，每个词都是有意义的，除了上下文信息，还要用到它本身的信息，即使是 &lt;MASK&gt;. 也就是知乎上说的，提取这两方面的信息。</p>
<p>再回过头，从语言模型的角度来看，依然是需要预测每一个词，但是绝大多数词它的 cross entropy loss 会很小，而主要去优化得到 &lt;MASK&gt; 对应的词。而 random/true token 告诉模型，你需要提防每一个词，他们也需要好好预测，因为他们不一定就是对的。</p>
<p>感谢知乎大佬！</p>
<h4 id="random-tokens-会-confuse-模型吗？"><a href="#random-tokens-会-confuse-模型吗？" class="headerlink" title="random tokens 会 confuse 模型吗？"></a>random tokens 会 confuse 模型吗？</h4><p>不会， random tokens 只占 15% * 10% = 1.5%. 这不会影响模型的性能。</p>
<p>还有一个问题， &lt;MASK&gt; 所占的比例很小，主要优化对象迭代一次对整个模型影响会很小，因而需要更多次迭代.</p>
<h3 id="next-sentence-generation"><a href="#next-sentence-generation" class="headerlink" title="next sentence generation"></a>next sentence generation</h3><p>对于下游是 Question Answering(QA), Natural Language Inference(NLI) 这样需要理解句子之间的相关性的任务，仅仅通过语言模型并不能获得这方面的信息。为了让模型能够理解句子之间的关系，作者提出了一个 binarized next sentence prediction.</p>
<p>具体方式是：  </p>
<p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/06.png"></p>
<p>50% 是正确的相邻的句子。 50% 是随机选取的一个句子。这个任务在预训练中能达到 97%-98% 的准确率，并且能很显著的提高 QA NLI 的任务。</p>
<h3 id="pre-training-procudure"><a href="#pre-training-procudure" class="headerlink" title="pre-training procudure"></a>pre-training procudure</h3><p>作者预训练使用的语料：BooksCorpus (800M words)，English Wikipedia (2,500M words)。 使用文档级别的语料很关键，而不是 shffule 的句子级别的语料，这样可以获得更长的 sentence.</p>
<p>获得训练样本：从预料库中抽取句子对，其中 50% 的两个句子之间是确实相邻的，50% 的第二个句子是随机抽取的。具体操作看代码吧</p>
<ul>
<li><p>batch_size 256.  </p>
</li>
<li><p>每一个 sentences 对： 512 tokens  </p>
</li>
<li><p>40 epochs  </p>
</li>
<li><p>Adam lr=1e-4, $\beta_1=0.9$, $\beta_2=0.999$, L2 weight decay 0.01  </p>
</li>
<li><p>learning rate warmup 10000 steps  </p>
</li>
<li><p>0.1 dropout  </p>
</li>
<li><p>gelu instead of relu  </p>
</li>
</ul>
<h3 id="Fine-tune-procedure"><a href="#Fine-tune-procedure" class="headerlink" title="Fine-tune procedure"></a>Fine-tune procedure</h3><h4 id="sequence-level-tasks"><a href="#sequence-level-tasks" class="headerlink" title="sequence-level tasks"></a>sequence-level tasks</h4><ul>
<li><p>比如 sentences pairs 的 Quora Question Pairs(QQP) 预测两个句子之间语义是否相同。如下图中（a）.  </p>
</li>
<li><p>如果是 single sentence classification 比如 Stanford Sentiment Treebank（SST-2）和 Corpus of Linguistic Acceptability（CoLA）这种分类问题。如下图（b）  </p>
</li>
</ul>
<p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/07.png"></p>
<p>只需要输出 Transformer 最后一层的隐藏状态中的第一个 token，也就是 [CLS]. 然后接上一个全链接映射到相应的 label 空间即可。</p>
<p>fine-tune 时的超参数跟 pre-training 时的参数大致相同。但是训练速度会很快</p>
<ul>
<li><p>Batch size: 16, 32  </p>
</li>
<li><p>Learning rate (Adam): 5e-5, 3e-5, 2e-5  </p>
</li>
<li><p>Number of epochs: 3, 4  </p>
</li>
</ul>
<p>语料库越大，对参数的敏感度越小。  </p>
<h4 id="token-level-tasks"><a href="#token-level-tasks" class="headerlink" title="token-level tasks."></a>token-level tasks.</h4><p><img src="/2018/12/17/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/09.png"></p>
<p>对于token-level classification(例如NER)，取所有token的最后层transformer输出，喂给softmax层做分类。</p>
<h2 id="如何使用-BERT"><a href="#如何使用-BERT" class="headerlink" title="如何使用 BERT"></a>如何使用 BERT</h2><h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><p><a target="_blank" rel="noopener" href="https://github.com/huggingface/pytorch-pretrained-BERT/blob/master/examples/run_classifier.py">https://github.com/huggingface/pytorch-pretrained-BERT/blob/master/examples/run_classifier.py</a></p>
<p>主要涉及到两个 类:  </p>
<ul>
<li><p>数据预处理   </p>
</li>
<li><p>预训练模型加载  </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pytorch_pretrained_bert <span class="keyword">import</span> BertTokenizer, BertForSequenceClassification, BertConfig, BertAdam， PYTORCH_PRETRAINED_BERT_CACHE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(args.bert_model, do_lower_case=args.do_lower_case)</span><br><span class="line"></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">&quot;./pre_trained_models/bert-base-uncased-vocab.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = BertForSequenceClassification.from_pretrained(<span class="string">&#x27;bert-base-uncased&#x27;</span>,</span><br><span class="line"></span><br><span class="line">          cache_dir=PYTORCH_PRETRAINED_BERT_CACHE / <span class="string">&#x27;distributed_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(args.local_rank),</span><br><span class="line"></span><br><span class="line">          num_labels = num_labels)</span><br><span class="line"></span><br><span class="line">model = BertForSequenceClassification.from_pretrained(<span class="string">&quot;pre_trained_models/bert-base-uncased.tar.gz&quot;</span>, num_labels=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 <code>bert-base-uncased</code> 可以分别用具体的 词表文件 和 模型文件 代替。从源代码中提供的链接下载即可。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pytorch_pretrained_bert <span class="keyword">import</span> BertTokenizer, BertForSequenceClassification, BertConfig, BertAdam， PYTORCH_PRETRAINED_BERT_CACHE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(args.bert_model, do_lower_case=args.do_lower_case)</span><br><span class="line"></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">&quot;./pre_trained_models/bert-base-uncased-vocab.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前一种方式是根据代码中提供的 url 去下载词表文件，然后缓存在默认文件夹下 <code>/home/panxie/.pytorch_pretrained_bert</code> 。后者是直接下载词表文件后，放在本地。相对来说，后者更方便。</p>
<p>这部分代码相对比较简单，根据自己的任务，继承 <code>DataProcessor</code> 这个类即可。</p>
<p>作为模型的输入，features 主要包括三个部分：  </p>
<ul>
<li><p>input_ids 是通过词典映射来的  </p>
</li>
<li><p>input_mask 在 fine-tune 阶段，所有的词都是 1, padding 的是 0  </p>
</li>
<li><p>segment_ids 在 text_a 中是 0, 在 text_b 中是 1, padding 的是 0  </p>
</li>
</ul>
<p>这里对应了前面所说的，input_idx 就是 token embedding, segment_ids 就是 Sentence Embedding. 而 input_mask 则表示哪些位置被 mask 了，在 fine-tune 阶段都是 1.</p>
<h4 id="加载预训练模型"><a href="#加载预训练模型" class="headerlink" title="加载预训练模型"></a>加载预训练模型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">!tar -tf pre_trained_models/bert-base-uncased.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./pytorch_model.bin</span><br><span class="line"></span><br><span class="line">./bert_config.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下载好的文件包中含有两个文件，分别是 config 信息，以及模型参数。</p>
<p>如果不用具体的文件，则需要从代码中提供的 url 下载，并缓存在默认文件夹 <code>PYTORCH_PRETRAINED_BERT_CACHE = /home/panxie/.pytorch_pretrained_bert</code></p>
<p>作为分类任务， num_labels 参数默认为 2.</p>
<p>运行时会发现提取预训练模型会输出如下信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">12</span>/<span class="number">26</span>/<span class="number">2018</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">41</span> - INFO - pytorch_pretrained_bert.modeling -   </span><br><span class="line"></span><br><span class="line">loading archive file pre_trained_models/bert-base-uncased.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>/<span class="number">26</span>/<span class="number">2018</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">41</span> - INFO - pytorch_pretrained_bert.modeling -   </span><br><span class="line"></span><br><span class="line">extracting archive file pre_trained_models/bert-base-uncased.tar.gz to temp <span class="built_in">dir</span> /tmp/tmpgm506dcx</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>/<span class="number">26</span>/<span class="number">2018</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">44</span> - INFO - pytorch_pretrained_bert.modeling -   </span><br><span class="line"></span><br><span class="line">Model config &#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;attention_probs_dropout_prob&quot;</span>: <span class="number">0.1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;hidden_act&quot;</span>: <span class="string">&quot;gelu&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;hidden_dropout_prob&quot;</span>: <span class="number">0.1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;hidden_size&quot;</span>: <span class="number">768</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;initializer_range&quot;</span>: <span class="number">0.02</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;intermediate_size&quot;</span>: <span class="number">3072</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;max_position_embeddings&quot;</span>: <span class="number">512</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;num_attention_heads&quot;</span>: <span class="number">12</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;num_hidden_layers&quot;</span>: <span class="number">12</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;type_vocab_size&quot;</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;vocab_size&quot;</span>: <span class="number">30522</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>/<span class="number">26</span>/<span class="number">2018</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">45</span> - INFO - pytorch_pretrained_bert.modeling -   </span><br><span class="line"></span><br><span class="line">Weights of BertForSequenceClassification <span class="keyword">not</span> initialized <span class="keyword">from</span> pretrained model:</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;classifier.weight&#x27;</span>, <span class="string">&#x27;classifier.bias&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>/<span class="number">26</span>/<span class="number">2018</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">45</span> - INFO - pytorch_pretrained_bert.modeling -   </span><br><span class="line"></span><br><span class="line">Weights <span class="keyword">from</span> pretrained model <span class="keyword">not</span> used <span class="keyword">in</span> BertForSequenceClassification:</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;cls.predictions.bias&#x27;</span>, <span class="string">&#x27;cls.predictions.transform.dense.weight&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;cls.predictions.transform.dense.bias&#x27;</span>, <span class="string">&#x27;cls.predictions.decoder.weight&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;cls.seq_relationship.weight&#x27;</span>, <span class="string">&#x27;cls.seq_relationship.bias&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;cls.predictions.transform.LayerNorm.weight&#x27;</span>, <span class="string">&#x27;cls.predictions.transform.LayerNorm.bias&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不得不去观察 <code>from_pretrained</code> 的源码：<a target="_blank" rel="noopener" href="https://github.com/huggingface/pytorch-pretrained-BERT/blob/8da280ebbeca5ebd7561fd05af78c65df9161f92/pytorch_pretrained_bert/modeling.py#L448">https://github.com/huggingface/pytorch-pretrained-BERT/blob/8da280ebbeca5ebd7561fd05af78c65df9161f92/pytorch_pretrained_bert/modeling.py#L448</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">missing_keys = []</span><br><span class="line"></span><br><span class="line">unexpected_keys = []</span><br><span class="line"></span><br><span class="line">error_msgs = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy state_dict so _load_from_state_dict can modify it</span></span><br><span class="line"></span><br><span class="line">metadata = <span class="built_in">getattr</span>(state_dict, <span class="string">&#x27;_metadata&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">state_dict = state_dict.copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metadata <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">    state_dict._metadata = metadata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">module, prefix=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line"></span><br><span class="line">    local_metadata = &#123;&#125; <span class="keyword">if</span> metadata <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> metadata.get(prefix[:-<span class="number">1</span>], &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    module._load_from_state_dict(</span><br><span class="line"></span><br><span class="line">        state_dict, prefix, local_metadata, <span class="literal">True</span>, missing_keys, unexpected_keys, error_msgs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, child <span class="keyword">in</span> module._modules.items():</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            load(child, prefix + name + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">load(model, prefix=<span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="built_in">hasattr</span>(model, <span class="string">&#x27;bert&#x27;</span>) <span class="keyword">else</span> <span class="string">&#x27;bert.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(missing_keys) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Weights of &#123;&#125; not initialized from pretrained model: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line"></span><br><span class="line">        model.__class__.__name__, missing_keys))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(unexpected_keys) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Weights from pretrained model not used in &#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line"></span><br><span class="line">        model.__class__.__name__, unexpected_keys))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tempdir:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Clean up temp dir</span></span><br><span class="line"></span><br><span class="line">    shutil.rmtree(tempdir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> model</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这部分内容解释了如何提取模型的部分参数.  </p>
<p> <code>missing_keys</code> 这里是没有从预训练模型提取参数的部分，也就是 <code>classifier</code> <code>[&#39;classifier.weight&#39;, &#39;classifier.bias&#39;]</code>层，因为这一层是分类任务独有的。  </p>
<p> <code>unexpected_keys</code> 则是对于分类任务不需要的，但是在预训练的语言模型中是存在的。查看 <code>BertForMaskedLM</code> 的模型就能看到，<code>cls</code> 层，是专属于语言模型的，在下游任务中都需要去掉。</p>
<p> 所以这部分代码实际上学到了如何选择预训练模型的部分参数～～棒啊！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-09-24T03:06:40.000Z" title="2018/9/24 上午11:06:40">2018-09-24</time>发表</span><span class="level-item"><time dateTime="2021-06-29T08:12:09.159Z" title="2021/6/29 下午4:12:09">2021-06-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/language-model/">language model</a></span><span class="level-item">13 分钟读完 (大约1992个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/09/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-character-embedding-and-ELMO/">论文笔记-character embedding and ELMO</a></h1><div class="content"><ul>
<li><p>paper: <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1508.06615.pdf">Character-Aware Neural Language Models</a>  </p>
</li>
<li><p>paper: <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1802.05365.pdf">Deep contextualized word representations</a></p>
</li>
</ul>
<h1 id="character-embedding"><a href="#character-embedding" class="headerlink" title="character embedding"></a>character embedding</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><blockquote>
<p>A language model is formalized as a probability distribution over a sequence of strings (words), and traditional methods usually involve making an n-th order Markov assumption and estimating n-gram probabilities via counting and subsequent smoothing (Chen and Goodman 1998). The count-based models are simple to train, but probabilities of rare n-grams can be poorly estimated due to data sparsity (despite smoothing techniques).  </p>
</blockquote>
<p>对语言模型的描述：语言模型是 一个单词序列的概率分布 的形式化描述（什么意思？就是比如这个句子长度为 10, 那么每个位置可能是词表中的任意一个词，而出现当前词是有一个概率的, 这个概率是依赖于之前的词的）。  </p>
<p>在传统的方法主要是运用 n阶马尔可夫假设来估计 n-gram 的概率，通过统计计数，以及子序列平滑的方式。这种基于计数的模型虽然简单，但是在数据稀疏的情况下，对不常见的 n-gram 的概率估计会很差。  </p>
<blockquote>
<p>While NLMs have been shown to outperform count-based n-gram language models (Mikolov et al. 2011), they are blind to subword information (e.g. morphemes). For example, they do not know, a priori, that eventful, eventfully, uneventful, and uneventfully should have structurally related embeddings in the vector space. Embeddings of rare words can thus be poorly estimated, leading to high perplexities for rare words (and words surrounding them). This is especially problematic in morphologically rich languages with long-tailed frequency distributions or domains with dynamic vocabularies (e.g. social media).  </p>
</blockquote>
<p>neural language models 将词嵌入到低维的向量中，使得语义相似的词在向量空间的位置也是相近的。然后 Mikolov word2vec 这种方式不能有效的解决子单词的信息问题，比如一个单词的各种形态，也不能认识前缀。这种情况下，不可避免的会造成不常见词的向量表示估计很差，对于不常见词会有较高的困惑度。这对于词语形态很丰富的语言是一个难题，同样这种问题也是动态词表的问题所在（比如社交媒体）。</p>
<h2 id="Recurrent-Neural-Network-Language-Model"><a href="#Recurrent-Neural-Network-Language-Model" class="headerlink" title="Recurrent Neural Network Language Model"></a>Recurrent Neural Network Language Model</h2><p>给定词表为 V，之前的序列是 $w_{1:t}=[w_1,..,w_t]$,在 RNN-LM 中通过全链接 affine transformation 计算 $w_{t+1}$ 个词的概率分布：  </p>
<p>$$Pr(w_{t+1}=j|w_{1:t})=\dfrac{exp(h_t\cdot p^j+q^j)}{\sum_{j’\in V}exp(h_t\cdot p^{j’}+q^{j’})}$$</p>
<p>其中 $h_t$ 是当前 t 时刻的隐藏状态。也就是先通过全链接映射到词表的 V 的维度，然后通过 softmax 计算其是词表中第 j 个词的概率。</p>
<p>然后假设训练预料库的 sentence 是 $w_{1:T}=[w_1,…,w_T]$,那么训练也就是最小化这个序列的 似然概率的负对数：</p>
<p>$$NLL=-\sum_{T}^{t=1}logPr(w_t|w_{1:t-1})$$</p>
<h2 id="Chracter-level-Convolution-Neural-Network"><a href="#Chracter-level-Convolution-Neural-Network" class="headerlink" title="Chracter-level Convolution Neural Network"></a>Chracter-level Convolution Neural Network</h2><p><img src="/2018/09/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-character-embedding-and-ELMO/01.png"></p>
<p>以单词 absurdity 为例，有 l 个字符（通常会 padded 到一个固定size），通过 character embedding 映射成矩阵 $C\in R^{d\times l}$. d 是 embedding size. 图中 embedding size 为 4.</p>
<p>然后使用卷积核 kernel H 做卷积运算, $H\in R^{d\times w}$，所以得到的 feature map $f^k\in R^{l-w+1}$. 跟之前 CNN 做文本分类其实挺像的, kernel 的长是 embedding size d, 宽度 w 分别是 2,3,4. 上图中蓝色区域为例，filter 宽度为 2 的个数是3, 那么卷积得到的 featur map 是 $3 \times (9-2+1) = 3\times 8$.</p>
<p>$$f^k[i]=tanh(&lt;C^k[* ,i:i-w+1], H&gt; +b)$$</p>
<p>&lt;&gt;表示做卷积运算(Frobenius inner product). 然后加上 bias 和 非线性激活函数 tanh.</p>
<p>接着基于 times 维度做 max pooling. 上图中 filter 宽度为 3,2,4 的个数分别为 4,3,5.所以得到长度为 4+3+5=12 的向量。</p>
<p>这里每一个 filter matrix 得到一个相应的特征 feature. 在通常的 NLP 任务中这些 filter 的总数 $h\in[100, 1000]$</p>
<h2 id="Highway-Network"><a href="#Highway-Network" class="headerlink" title="Highway Network"></a>Highway Network</h2><p>通过卷积层得到单词 k 的向量表示为 $y^k$.</p>
<p>Highway Network 分为两层 layer.</p>
<ul>
<li>one layer of an MLP applies an affine transformation:</li>
</ul>
<p>$$z=g(W_y+b)$$</p>
<ul>
<li>one layer 有点类似 LSTM 中的 gate 机制：</li>
</ul>
<p>$$z=t\circ g(W_Hy+b_H)+(1-t)\circ y$$</p>
<p>其中  g 是非线性函数。$t=\sigma(W_Ty+b_T)$. t 成为 transform gate, (1-t) 是 carry gate. 同 LSTM 类似， highway network 允许输出能自适应的从 $y^k$ 中直接获取信息。</p>
<h1 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h1><p>传统的提取 word embedding 的方法，比如 word2vec 和 language model， 前者是通过词与词之间的共现，后者是 contextual，但他们都是获得固定的 embedding，也就是每一个词对应一个单一的 embedding.  而对于多义词显然这种做法不符合直觉, 而单词的意思又和上下文相关, ELMo的做法是我们只预训练 language model, 而 word embedding 是通过输入的句子实时输出的, 这样单词的意思就是上下文相关的了, 这样就很大程度上缓解了歧义的发生. 且 ELMo 输出多个层的 embedding 表示, 试验中已经发现每层 LM 输出的信息对于不同的任务效果不同, 因此对每个 token 用不同层 embedding 表示会提升效果.</p>
<p>个人觉得，可以从这个角度去理解。RNN 可以看做一个高阶马尔可夫链，而不同于 马尔可夫模型，RNN 中的状态转移矩阵是用神经网络来模拟的，也就是我们计算隐藏层所用的 $h_t=tanh(w_{hh}h_{t-1}+w_{hx}x_t)$. 这个状态转移是动态的，也是不断更新的。而使用 语言模型 来训练 RNN/LSTM 目的就是得到这样的一套参数，使得它能学习到任何 合理的，自然的 sentence. 所以，这个语料库越大越好。事实上，有监督的训练也可以达到这个目的，但是有监督的数据有限，并且整个模型是有偏置的，比如文本分类的任务去训练，那么它更倾向于 局部信息。相比之下，机器翻译作为有监督的效果会更好，最好的还是语言模型呢，不仅可用的数据量很大，而且因为要预测每一个词的信息，它会努力结合每一个词的上下文去学习这个词的表示。这也正是我们需要的。ELMo 和 BERT 都是这样的道理，而 BERT 的优势前一篇 blog 说过了。</p>
<h2 id="Bidirectional-language-models"><a href="#Bidirectional-language-models" class="headerlink" title="Bidirectional language models"></a>Bidirectional language models</h2><p>给定 sentence $t_1, t_2,…,t_N$, 通过前面的词 $t_1,..,t_{k-1}$ 计算 token $t_k$ 的概率分布:</p>
<p><img src="/2018/09/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-character-embedding-and-ELMO/06.png"></p>
<p>反向：</p>
<p><img src="/2018/09/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-character-embedding-and-ELMO/02.png"></p>
<p>语言模型的训练就是采用极大似然估计，最大化这个概率：</p>
<p><img src="/2018/09/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-character-embedding-and-ELMO/03.png"></p>
<p>传统的方法就是 提取出对应位置的向量表示作为对应位置的词向量 context-independent token representation $x_k^{LM}$.</p>
<h2 id="ELMo-1"><a href="#ELMo-1" class="headerlink" title="ELMo"></a>ELMo</h2><blockquote>
<p>ELMo is a task specific combination of the intermediate layer representations in the biLM.</p>
</blockquote>
<p>ELMo 实际上只是下游任务的中间层，跟 BERT 一样。但也有不同的是， ELMo 每一层的向量表示会获得不同的 信息。底层更能捕捉 syntax and semantics 信息，更适用于 part-of-speech tagging 任务，高层更能获得 contextual 信息，更适用于 word sense disambiguation 任务。所以对不同的任务，会对不同层的向量表示的利用不同。</p>
<p><img src="/2018/09/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-character-embedding-and-ELMO/05.png"></p>
<p>在使用 ELMo 进行下游有监督训练时，通常是这样 $[x_k; ELMo_k^{task}]$. 对于 SQuAD 这样的任务，$[h_k, ELMo_k^{task}]$.</p>
<h2 id="Model-architecture"><a href="#Model-architecture" class="headerlink" title="Model architecture"></a>Model architecture</h2><blockquote>
<p>The final model uses L = 2 biLSTM layers with 4096 units and 512 dimension projections and a residual connection from the first to second</p>
</blockquote>
<p>layer. The context insensitive type representation uses 2048 character n-gram convolutional filters followed by two highway layers and a linear projection down to a 512 representation.</p>
<p>具体模型还是得看代码。</p>
</div></article></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="panxiaoxie"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">panxiaoxie</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">121</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">40</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">38</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PanXiebit" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PanXiebit"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/ftdpanxie@gmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/PanXiebit" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="ftdpanxie@gmail.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">email</span></span><span class="level-right"><span class="level-item tag">ftdpanxie@gmail.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CSAPP/"><span class="level-start"><span class="level-item">CSAPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/DRL/"><span class="level-start"><span class="level-item">DRL</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/GAN/"><span class="level-start"><span class="level-item">GAN</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/GAN-RL/"><span class="level-start"><span class="level-item">GAN, RL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/ML/"><span class="level-start"><span class="level-item">ML</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cs224d/"><span class="level-start"><span class="level-item">cs224d</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/generation/"><span class="level-start"><span class="level-item">generation</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/generative-models/"><span class="level-start"><span class="level-item">generative models</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/interview/"><span class="level-start"><span class="level-item">interview</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/machine-translation/"><span class="level-start"><span class="level-item">machine translation</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/pytorch/"><span class="level-start"><span class="level-item">pytorch</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/reinforcement-learning/"><span class="level-start"><span class="level-item">reinforcement learning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/sign-language-recognition/"><span class="level-start"><span class="level-item">sign language recognition</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/transfer-learning/"><span class="level-start"><span class="level-item">transfer learning</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/transformer/"><span class="level-start"><span class="level-item">transformer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/"><span class="level-start"><span class="level-item">文本分类</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文笔记</span></span><span class="level-end"><span class="level-item tag">40</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/DL/"><span class="level-start"><span class="level-item">DL</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/ESA/"><span class="level-start"><span class="level-item">ESA</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/GAN/"><span class="level-start"><span class="level-item">GAN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/MRC-and-QA/"><span class="level-start"><span class="level-item">MRC and QA</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Machine-Translation/"><span class="level-start"><span class="level-item">Machine Translation</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Transformer/"><span class="level-start"><span class="level-item">Transformer</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/capsules/"><span class="level-start"><span class="level-item">capsules</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/computer-vision/"><span class="level-start"><span class="level-item">computer vision</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/constrast-learning/"><span class="level-start"><span class="level-item">constrast learning</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/data-augmentation/"><span class="level-start"><span class="level-item">data augmentation</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/dialogue-system/"><span class="level-start"><span class="level-item">dialogue system</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/language-model/"><span class="level-start"><span class="level-item">language model</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/machine-translation/"><span class="level-start"><span class="level-item">machine translation</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/open-set-recognition/"><span class="level-start"><span class="level-item">open set recognition</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/sentence-embedding/"><span class="level-start"><span class="level-item">sentence embedding</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/text-matching/"><span class="level-start"><span class="level-item">text matching</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/vision-language/"><span class="level-start"><span class="level-item">vision-language</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/panxiaoxie.png" alt="潘小榭" height="28"></a><p class="is-size-7"><span>&copy; 2022 Xie Pan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>